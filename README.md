# Valet
Manage your [Kinode](https://github.com/kinode-dao/kinode) nodes via the web.

## Features
- [ ] Sign in with X (fka Twitter)
- [ ] Choose a node name
- [ ] View node status

```
A) You'll need to create a route that, when appended with a JWT will ingest that JWT for subsequent use a bearer token for the current user.  So for example, let's say you made a route handling /app/process-jwt?token=ey94j49f03df.ey3099ur4thiswholethingisthejwt94389340.ey3839823 such that then if the user clicked a Retrieve My User Details button, making a request to the hosting backend at api.staging.kinode.net/get-user-info-x, you'd include a header 'Authorization: bearer ey94j49f03df.ey3099ur4thiswholethingisthejwt94389340.ey3839823'.
and
B) When the user clicks Sign On With X, you'll make a POST to api.staging.kinode.net/x/get-redirect-url with a payload of {"finalRedirectUrl": "https://thisismykinodeurl.kinode.net/app/process-jwt?token="} (That's assuming the example route above in A.  Make it whatever you want it to be!  Whatever you put in there, the user will eventually find themselves at the very end of the process at that page with their fresh JWT appended to the end of it.)  We'll respond with json like {"url": "https://api.twitter.com/oauth/authenticate?oauth_token=someoauthtoken"}, and you should 302 the user to that address.
The actors will be "the user" (and the user's browser), "the frontend app you're making", "the hosting backend", and "X" (which won't directly be involved in the endpoints you hit but will nonetheless be involved in the flow).
1) The user will be using your frontend, and decides to engage with your "Sign In With X" button/link/whatever.  They click and wait for your app to send them a response.
2) You POST a request to the hosting backend at /x/get-redirect-url with payload to specify the "finalRedirectUrl", which will be the page you want the user to arrive at once their userToken is generated (the exact same sort of JWT that the backend supplies after a standard login).  This is the endpoint mentioned in A above.
3) The hosting backend gets this post, talks to X, saves the finalRedirectUrl and some info X sent us to a database table, and responds to your app with some json like {"redirect_url":"https://api.twitter.com/oauth/authenticate?oauth_token=837263something238742398"}.
4) Your app can now finally respond to the user with a 302 to the redirect URL.  The user's browser will then make a request to X.
5) Depending on whether or not the user is already logged in and/or has authorized the hosting backend to access their X info, by the time logging in / authorizing has taken place, X will respond to the user's browser with a redirect back to the hosting backend, passing some tokens that we need for OAuth.
6) The hosting backend will process that info, get all the info it needs about the X user (and will not need to talk to X after that), and either retrieve an existing user or create a new one and create a user JWT to "log in" that user.  And the hosting backend will respond to the user's browser with a redirect to the finalRedirectUrl with the JWT appended as a querystring param.
7) That finalRedirectUrl should be your frontend, and it should store that appended JWT in a cookie or local storage or whatever.
8) At that point, your app running on someone's kinode can make any manner of authenticated requests to the hosting backend by including the JWT as a bearer token in the authorization header.  Ultimately, this will be used to the launch a free kinode for the user (if they don't already have a free one), but for now, just call the /get-user-info-x endpoint that will return a json payload with the hosting userId, the X userId, and the X screen name.  That way you can have something to call and display so it's easy to verify to you and the user that the whole OAuth process worked.
Step 6 is the end of anything OAuth-releated, and all subsequent stuff is just normal user management, same as someone who logged in with email/password, including refreshing their token.  Only after they log out / time out and want to log back in again will OAuth be engaged again from Step 1.
That should do the trick.  You'll never need to interact with X directly, although in step 4 you'll be 302ing your user to an X address (because that'll be where I tell you you should 302 them to in step 3).
So I've already mentioned the GET https://api.staging.kinode.net/get-user-info-x endpoint which will just return a small json payload of info about the currently logged in user.  You'll need to pass in a 'Authorization: bearer eywhatever_the_JWT_was_you_got_in_step_7' header, which is true for all of these endpoints that follow, and if you don't, you'll get back a 503.  This endpoint is a good one for confirming you've got the OAuth flow working well.
Another key one you'll be using a lot will be GET https://api.staging.kinode.net/get-user-kinodes   If the logged in user doesn't have any kinodes associated with their login yet, you'll just get back an empty array.  However if they have claimed one, you'll get back an array with a single kinode object (it's possible to have multiple associated with a login, but not in the free giveaway scenario).  It'll look something like this: [{"email":null,"payment_status":"Pending","id":49,"ship_type":"kinode","screen_name":"kvg1R9kmz0zoKck","link":"https://lamotime9.staging.kinode.net","ship_status":"active","user_id":12,"created_at":"2024-03-01T20:03:50.843Z","updated_at":"2024-03-01T20:05:03.452Z","last_restarted":"2024-03-01T20:03:50.843Z","product_id":2,"maintenance_window":null,"product_type":"kinode","kinode_name":"lamotime9","product_title":"Base Kinode Instance","product_description":"base kinode instance"}]  The fields you'll be most interested in are the ID (because you'll potentially use that in subsequent calls), ship_status and link (which will need to be "active" and start with http(s) respectively to indicate an available kinode), and kinode_name which will reflect the .os KNS for this node (the value will not have ".os" appended).  This information will be useful to display to a returning user. 
When someone is looking for an .os name to use for their free kinode, you can use GET https://api.staging.kinode.net/check-dot-os-availability/:the_name_you_are_looking_for   That variable field in the path should not contain the .os suffix.  We will automatically look for unowned .os names.
When they have found an available name and want to launch their free kinode if they're so entitled, hit the POST https://api.staging.kinode.net/free-kinode-eligibility-boot endpoint with an application/json payload of {"productId":2, "kinodeName":"the_available_name", "kinodePassword":"the_SHA256_hash_of_the_password_typed_by_the_user"}  Note well that that password has to be hashed before you ever POST it to the backend, and must be in hexadecimal with the 0x prefix.  Assuming all is okay (i.e., the auth token is good, the name is available, and the user doesn't already have a kinode), you'll immediately get back an asynchronous 200 { message: "Boot initiated" } response.  You'll then need to poll the GET https://api.staging.kinode.net/get-user-kinodes again every 10 or 15 seconds or so to know when the kinode is ready (we wait a couple of blocks before completing the process).  You'll be looking specifically for the ship_status and link to show "active" and start with http(s) respectively.  At first, you will probably see "active" but the link will be a dummy placeholder value. (I can explain why this is done in the future if you're interested.)  Once you get back the valid values, you can tell the user that they're all set.
Lastly for now, if the user has ever forgotten their password and needs to reset it, there's a PUT https://api.staging.kinode.net/reset-kinode-password/:kinode-id endpoint.  Like the others, it requires an auth token, and it takes an application/json payload like {"kinodePassword": "0x253c2e786c2414dcaec8dbf11df515b5075371454b93a5687d24d96ddbf3b939"}.  This consumes gas (If you've been following the pre-0.6.0 discussion you might already know why, but if not I can explain), and we might put a cap on its use.  It blocks until the chain write is complete and confirmed.
Oh, one more, in case you need to get rid of a user's existing node so you can launch another one:  There's a PUT https://api.staging.kinode.ne/deactivate-kinode/:kinode-id endpoint that'll block until the node is shut down and archived.  Both this endpoint and the previous check to make sure the kinode-id passed is in fact owned by the user in the JWT.
Hope these are useful, and feel free to ping me.  I'll respond if/when I can, and I'll be fully back for Wednesday.

```